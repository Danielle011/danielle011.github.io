---
title: 혈당분석기 03. 데이터 전처리 (3/3) - 애플 헬스 데이터
date: 2024-10-31 20:00:00 +09:00
categories: [혈당분석기, 데이터 프로세싱]
tags: [혈당, 건강]
---

이번 포스트에서는 애플 헬스 데이터 프로세서 제작 과정에 대해 정리해 보려고 한다.

대상 데이터가 많고, 각 데이터 별로 가지는 값과 값의 특성에 따른 처리 방법들이 상이하다보니 Claude에 요청 프롬프트와 함께 해당 애플 헬스 원본 데이터를 복사해서 전달하는 과정을 기본으로, 오류가 생기면 특정 날짜의 xml 로우 데이터 전체를 전달하며 클로드가 계산을 해보고 오류를 찾도록 유도하며 진행했다.

전체 코드 작성 방식은 프로세싱 대상 데이터 종류가 많은 점을 고려하여 각 standalone 코드를 우선 만들고 맞는 아웃풋을 내는것을 확인한 후, 클로드로 리팩토링하여 합치는 방식으로 진행했다.

## 1. 대상 데이터
우선 02.데이터 수집 포스트에서 정리했듯 사용할 애플 헬스 데이터는 아래 6가지였다.
- Activity Data: Step Count, Distance Walking Running, Flight Climbed
- Sleep
- Workout
- Heart rate 

## 2. 각 데이터 별 프로세싱 주요 고려 사항

### 2.1 Activity 
신체 활동 데이터로 분석에 활용하기로 결정한 Step Count, Distance Walking Running, Flight Climbed 은 아래와 같은 공통점이 있다.
- 공통적으로 creationdata, startdate, endate, value 의 심플한 구조이다
- 해당 활동이 발생 시 데이터 소스(애플워치, 아이폰 등)가 자동으로 기록된다
- 기록 인터벌이 상이하다. 각 데이터 전체를 뽑아 endData - startDate하여 인터벌을 살펴봤을때 최대값은 10분이고 대부분 몇초에서 1-2분이었다.  

짧게는 몇 초에서 1-2분, 길게는 10분의 매우 상이한 인터벌을 가진 데이터를 프로세싱하는 방법으로 매 10분 인터벌으로 aggregation하는 방법을 택했다. 데이터 자체의 최대값이 10분 이기도 하고, 혈당 관점에서 이 3개의 신체활동은 이벤트 발생에 따라 시시각각 즉각적인 영향을 주는 것들이기 때문에 각 이벤트 발생 시점을 명확하게 확인하되, 과도하게 쪼갠 데이터는 데이터의 크기만 키울 뿐 큰 의미를 가지기 어려운데, 10분이 적절한 선이라고 생각했다.

`Distance Walking Running`

```xml
<Record type="HKQuantityTypeIdentifierDistanceWalkingRunning" sourceName="A’s Apple Watch" sourceVersion="10.4" device="&lt;&lt;HKDevice: 0x3033814a0&gt;, name:Apple Watch, manufacturer:Apple Inc., model:Watch, hardware:Watch6,10, software:10.4&gt;" unit="km" creationDate="2024-08-17 12:29:59 +0900" startDate="2024-04-19 11:35:37 +0900" endDate="2024-04-19 11:40:43 +0900" value="0.317411">
```

`Flights Climbed`

```xml
<Record type="HKQuantityTypeIdentifierFlightsClimbed" sourceName="A’s Apple Watch" sourceVersion="10.4" device="&lt;&lt;HKDevice: 0x303381a90&gt;, name:Apple Watch, manufacturer:Apple Inc., model:Watch, hardware:Watch6,10, software:10.4&gt;" unit="count" creationDate="2024-05-02 12:26:04 +0900" startDate="2024-05-02 12:16:00 +0900" endDate="2024-05-02 12:23:27 +0900" value="19"/>
```

`Step Count`

```xml
<Record type="HKQuantityTypeIdentifierStepCount" sourceName="A's iPhone" sourceVersion="17.5.1" device="&lt;&lt;HKDevice: 0x303381770&gt;, name:iPhone, manufacturer:Apple Inc., model:iPhone, hardware:iPhone14,4, software:17.5.1&gt;" unit="count" creationDate="2024-08-07 12:50:06 +0900" startDate="2024-08-07 12:39:03 +0900" endDate="2024-08-07 12:49:04 +0900" value="1034"/>
```

### 2.2 Sleep
수면은 로우 데이터 구조를 파악하는 것이 중요했다.

아래 하룻밤의 전체 수면기록을 살펴보면, 나의 경우 아이폰과 애플워치가 각각 수면을 기록하고 있었고, 아이폰은 inbed 값으로 애플워치는 sleep stages (Core, REM, Deep) 별로 상세한 값을 기록한다.

동일한 날의 연속되는 수면 기록 여부를 판별하기 위한 값으로는 creationDate를 활용할 수 있을것으로 보였다. 애플의 알고리즘이 하나의 수면기록을 이루는 sleep stages들에 동일한 creationDate를 부여하고 있는 것으로 추측되었다. 

더불어 워치의 수면기록 값들은 아래와 같은 패턴을 가지는데, 수면 중간 awake 상태가 발생하면 앞선 연속된 sleep stages를 inbed로 묶어주며 처리하는것으로 보였다. 이러한 과정 역시 모두 클로드에게 이해하게 도와달라,,라며 진행했고 아래 그림도 클로드가 그렸다. 아래 에시인 하룻밤의 수면 데이터를 주고 visualization을 요청했다.

![watch sleep staes](https://github.com/user-attachments/assets/74cb12dd-fc58-439a-90a0-f1234e557b0e){: .align-left width="100%"}

```xml
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's iPhone" sourceVersion="17.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-05 23:59:52 +0900" endDate="2024-11-06 00:00:15 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's iPhone" sourceVersion="17.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:03:08 +0900" endDate="2024-11-06 00:03:13 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's iPhone" sourceVersion="17.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:04:29 +0900" endDate="2024-11-06 00:04:34 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's iPhone" sourceVersion="17.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:05:04 +0900" endDate="2024-11-06 00:05:22 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:23:10 +0900" endDate="2024-11-06 00:26:40 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:23:10 +0900" endDate="2024-11-06 00:26:40 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:26:40 +0900" endDate="2024-11-06 00:27:40 +0900" value="HKCategoryValueSleepAnalysisAwake">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:27:40 +0900" endDate="2024-11-06 00:44:40 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:44:40 +0900" endDate="2024-11-06 00:53:40 +0900" value="HKCategoryValueSleepAnalysisAsleepDeep">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:53:40 +0900" endDate="2024-11-06 01:00:10 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:00:10 +0900" endDate="2024-11-06 01:04:10 +0900" value="HKCategoryValueSleepAnalysisAsleepDeep">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:04:10 +0900" endDate="2024-11-06 01:13:10 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:13:10 +0900" endDate="2024-11-06 01:20:40 +0900" value="HKCategoryValueSleepAnalysisAsleepDeep">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:20:40 +0900" endDate="2024-11-06 01:24:10 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:27:40 +0900" endDate="2024-11-06 01:24:10 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:24:10 +0900" endDate="2024-11-06 01:24:40 +0900" value="HKCategoryValueSleepAnalysisAwake">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:24:40 +0900" endDate="2024-11-06 01:26:10 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:26:10 +0900" endDate="2024-11-06 01:35:10 +0900" value="HKCategoryValueSleepAnalysisAsleepREM">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:35:10 +0900" endDate="2024-11-06 02:00:40 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 02:00:40 +0900" endDate="2024-11-06 02:20:40 +0900" value="HKCategoryValueSleepAnalysisAsleepDeep">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 02:20:40 +0900" endDate="2024-11-06 02:56:40 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 02:56:40 +0900" endDate="2024-11-06 03:32:10 +0900" value="HKCategoryValueSleepAnalysisAsleepREM">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A’s Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 03:32:10 +0900" endDate="2024-11-06 03:54:10 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 03:54:10 +0900" endDate="2024-11-06 03:59:10 +0900" value="HKCategoryValueSleepAnalysisAsleepDeep">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 03:59:10 +0900" endDate="2024-11-06 04:20:40 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 04:20:40 +0900" endDate="2024-11-06 04:24:10 +0900" value="HKCategoryValueSleepAnalysisAsleepDeep">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 04:24:10 +0900" endDate="2024-11-06 04:46:10 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 04:46:10 +0900" endDate="2024-11-06 05:20:10 +0900" value="HKCategoryValueSleepAnalysisAsleepREM">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 05:20:10 +0900" endDate="2024-11-06 06:02:40 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 06:02:40 +0900" endDate="2024-11-06 06:22:40 +0900" value="HKCategoryValueSleepAnalysisAsleepDeep">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 06:22:40 +0900" endDate="2024-11-06 06:29:10 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 06:29:10 +0900" endDate="2024-11-06 06:45:40 +0900" value="HKCategoryValueSleepAnalysisAsleepREM">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 06:45:40 +0900" endDate="2024-11-06 07:36:10 +0900" value="HKCategoryValueSleepAnalysisAsleepCore">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's Apple Watch" sourceVersion="10.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 01:24:40 +0900" endDate="2024-11-06 07:36:10 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's iPhone" sourceVersion="17.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 00:12:54 +0900" endDate="2024-11-06 07:39:07 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's iPhone" sourceVersion="17.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 07:44:13 +0900" endDate="2024-11-06 07:49:44 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
<Record type="HKCategoryTypeIdentifierSleepAnalysis" sourceName="A's iPhone" sourceVersion="17.6.1" creationDate="2024-11-06 07:53:53 +0900" startDate="2024-11-06 07:53:46 +0900" endDate="2024-11-06 07:53:52 +0900" value="HKCategoryValueSleepAnalysisInBed">
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
</Record>
```

### 2.3 Workout
Workout은 데이터 자체는 값이 다양하고 복잡한데, 다른 연산이 필요하지 않고 있는 값을 그대로 가져오면 되는것이여서 그런지, 클로드에 아래와 같이 하나의 Workout 세션 로우 데이터를 복사해서 줬을때 특별한 어려움 없이 코드를 잘 만들어 주었다.

```xml
<Workout workoutActivityType="HKWorkoutActivityTypeRunning" duration="51.70873240828514" durationUnit="min" sourceName="A’s Apple Watch" sourceVersion="10.3.1" device="&lt;&lt;HKDevice: 0x30336fcf0&gt;, name:Apple Watch, manufacturer:Apple Inc., model:Watch, hardware:Watch6,10, software:10.3.1&gt;" creationDate="2024-03-01 19:37:25 +0900" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900">
<MetadataEntry key="HKIndoorWorkout" value="0"/>
<MetadataEntry key="HKElevationAscended" value="32718 cm"/>
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
<MetadataEntry key="HKWeatherHumidity" value="4100 %"/>
<MetadataEntry key="HKWeatherTemperature" value="23.216 degF"/>
<MetadataEntry key="HKAverageMETs" value="8.6307 kcal/hr·kg"/>
<WorkoutEvent type="HKWorkoutEventTypeSegment" date="2024-03-01 18:44:21 +0900" duration="10.76069202224414" durationUnit="min"/>

-WorkoutEvent 기록 중략-

<WorkoutEvent type="HKWorkoutEventTypePause" date="2024-03-01 19:37:17 +0900"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierStepCount" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" sum="6027.23" unit="count"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierRunningGroundContactTime" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" average="311.099" minimum="236" maximum="359" unit="ms"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierRunningPower" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" average="104.456" minimum="33" maximum="224" unit="W"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierActiveEnergyBurned" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" sum="325.802" unit="kcal"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierBasalEnergyBurned" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" sum="54.2404" unit="kcal"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierRunningVerticalOscillation" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" average="8.15909" minimum="7.7" maximum="9.3" unit="cm"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierRunningSpeed" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" average="5.48007" minimum="0.638372" maximum="10.1736" unit="km/hr"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierRunningStrideLength" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" average="0.866364" minimum="0.75" maximum="1.02" unit="m"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierDistanceWalkingRunning" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" sum="4.75255" unit="km"/>
<WorkoutStatistics type="HKQuantityTypeIdentifierHeartRate" startDate="2024-03-01 18:44:21 +0900" endDate="2024-03-01 19:37:17 +0900" average="156.519" minimum="110" maximum="177" unit="count/min"/>
<WorkoutRoute sourceName="A’s Apple Watch" sourceVersion="10.3.1" creationDate="2024-03-01 19:37:28 +0900" startDate="2024-03-01 18:44:22 +0900" endDate="2024-03-01 19:37:17 +0900">
<MetadataEntry key="HKMetadataKeySyncVersion" value="2"/>
<MetadataEntry key="HKMetadataKeySyncIdentifier" value="72D49AF6-1141-4E0B-9244-1D7C77B549E7"/>
<FileReference path="/workout-routes/route_2024-03-01_7.37pm.gpx"/>
</WorkoutRoute>
<MetadataEntry key="HKIndoorWorkout" value="0"/>
<MetadataEntry key="HKElevationAscended" value="32718 cm"/>
<MetadataEntry key="HKTimeZone" value="Asia/Seoul"/>
<MetadataEntry key="HKWeatherHumidity" value="4100 %"/>
<MetadataEntry key="HKWeatherTemperature" value="23.216 degF"/>
<MetadataEntry key="HKAverageMETs" value="8.6307 kcal/hr·kg"/>
</Workout>
```


### 2.4 Heart rate

심박수 역시 구조가 심플하고, 특별한 연산이 필요하지 않아 클로드가 로우 데이터 예시만 보고 프로세싱 코드를 잘 작성해주었다.

```xml
<Record type="HKQuantityTypeIdentifierHeartRate" sourceName="A’s Apple Watch" sourceVersion="10.3.1" device="&lt;&lt;HKDevice: 0x303347750&gt;, name:Apple Watch, manufacturer:Apple Inc., model:Watch, hardware:Watch6,10, software:10.3.1&gt;" unit="count/min" creationDate="2024-04-04 12:14:42 +0900" startDate="2024-04-04 12:14:41 +0900" endDate="2024-04-04 12:14:41 +0900" value="105">
<MetadataEntry key="HKMetadataKeyHeartRateMotionContext" value="0"/>
</Record>
```

## 3. Prompt 설계
위의 각 데이터 별 프로세싱 주요 고려 사항에서 살펴 보았듯, Activity 3종과 수면 데이터가 프로세싱이 복잡하여 프롬프트를 잘 설계해야 했고, 이외 운동과 심박수는 구조가 간단하여 특별히 복잡한 프롬프트가 필요하지 않았다. 추가로 혈당 데이터 기반으로 데이터 기간을 다이내믹하게 적용하는 내용이 필요했다.

이에 데이터 기간, Activity 3종 그리고 수면 이렇게 3가지 요소에 대한 프롬프팅 내용을 정리해보고자 한다. 프롬프트는 결과를 보고 계속 수정했지만 기본적으로 아래와 같은 정보를 전달하며 요청했다.
### 3.1 데이터 기간 필터링

혈당 데이터를 가져와서, 혈당 데이터의 각 측정 차수의 시작과 끝 값을 기간으로 가지도록 설계했다.

```
I'm working on a project to analyze my activity patterns alongside my blood glucose levels. I have data from my CGM (Continuous Glucose Monitor) and Apple Health, and I need help creating a function that figures out exactly when I was wearing my CGM device.

Here's what I need:

1. The function should read my CGM data from a CSV file that contains:
   - The date and time of each glucose reading
   - A measurement number that shows which CGM session it belongs to
   
2. For each CGM session (identified by the measurement number), I need to know:
   - When the session started (first reading)
   - When the session ended (last reading)

3. Convert all timestamps to KST (UTC+9). Use consistent timezone handling throughout

4. The function should give me a list of start and end times for each CGM session
```

### 3.2 Activity 3종
Activity 3종 (Step count, Distance, Flight Climbed) 는 데이터 소스에 따른 데이터 중복 방지와 10분 단위 aggregation이 중요했다. 따라서 아래의 기준으로 설계하였고, 최종 아웃풋은 하나의 테이블로 10분 단위 인터벌로 step count, distance, flights climbed 컬럼을 가지도록 잡았다.

- 데이터 소스에 따른 데이터 중복 방지
	- iphone과 watch를 모두 가지고 있는 상황에서 신체 활동을 했다면, 정확한 세부 시간이나 수치는 차이가 있을 수 있지만, 반드시 overlap이 발생할 수 밖에 없다고 생각했다. 따라서 아래와 같이 설계하였다.
		- 오버랩이 있을 경우는 watch 데이터를 우선시
		- 오버랩이 없는 경우에는 iphone 데이터도 처리
- 10분 단위 aggregation
	- 매 10분 단위 인터벌 (00:00-00:10, 00:10-00:20 etc)로 데이터 합산
	- 인터벌에 걸쳐있는 데이터는 (e.g., 12:15 - 12:25) 시간에 비례하여 distribute

```
I need help creating a Python script to process activity data from Apple Health XML export. The script should:

1. Parse three types of activities:
   - Step count
   - Distance walking/running
   - Flights climbed

2. For each activity record, extract:
   - Start and end timestamps
   - Activity value
   - Source device
   - Device name

3. Handle data deduplication with these requirements:
   - When Apple Watch and iPhone data overlap in time, prioritize Watch data
   - Keep non-overlapping iPhone data
   - Sort records by timestamp

4. Aggregate the data with these specifications:
   - Combine records into 10-minute intervals
   - Distribute activity values proportionally across intervals
   - Handle records that span multiple intervals

5. The final output should be:
   - A DataFrame with columns for start_time, end_time, steps, distance, and flights
   - All timestamps in KST timezone
```

### 3.3 Sleep 
수면 역시 데이터 소스 처리가 중요했다. iphone과 watch 모두 수면을 기록하지만, 워치가 더 정확한 값이라고 볼 수 있기에 creation date 기준으로 워치 데이터가 있으면 해당 데이터를 보고, 없고 아이폰 데이터만 있으면 아이폰 데이터를 보도록 설계했다.

아웃풋은 수면 시작과 끝, 총 수면 시간, 각 sleep stages 별 시간을 뽑도록 했으며, 이때 awake 상태는 포함되지 않도록 했다.

```
I need help creating a function to process my sleep data from Apple Health.

1. Sleep Data Organization:
- Each sleep session (iPhone or Watch) is grouped under same creation_date (date only, ignore time)
- Watch data contains detailed sleep stages (Core/Deep/REM) plus InBed spans
- iPhone data only contains InBed records

2. Data Processing Priority:
- For each creation_date (day), check data sources:
  * If Watch data exists for that date -> Use ONLY Watch data (completely ignore iPhone data)
  * If only iPhone data exists -> Use iPhone InBed records

3. Sleep Calculation Rules:
- For Watch Data: 
  * Only use actual sleep states (AsleepCore/AsleepDeep/AsleepREM)
  * Calculate total_sleep_time = sum of all sleep states
  * Calculate individual durations for core_sleep_time, deep_sleep_time, rem_sleep_time

- For iPhone Data:
  * Use InBed records duration

4. Output Format:
- start_date: Beginning of sleep session
- end_date: End of sleep session
- total_sleep_time: Total duration of all sleep states
- core_sleep_time: Duration of core sleep
- deep_sleep_time: Duration of deep sleep
- rem_sleep_time: Duration of REM sleep
- All times should be in KST timezone

```

## 4. 애플 헬스 프로세서 제작 과정 with Claude
1. 목적을 설명하고, 프로세싱 대상 데이터 타입별로 xml 로우 데이터 예시를 준다.
2. 각 데이터 타입의 standalone 코드를 작성하도록 한다.
3. 로컬에서 코드 작동하여 아웃풋이 맞게 나오는지 확인하고, 잘못 나올경우 에러 메시지를 전달하거나 실제 로우 데이터 일부와 내가 계산한 내용을 전달하는 등 프롬프트를 수정하여 개선한다.
4. 각 데이터의 개별 코드가 모두 잘 작동하면 하나의 코드로 리팩토링을 요청한다.
5. 하나의 코드로 모듈 간 데이터가 모두 잘 나오는지 확인한다. 잘못된 결과 나올 경우 에러 메시지 전달하고 프롬프트 수정하며 반복한다.

## 5. 최종 애플 헬스 프로세서 코드

```python
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta, timezone
import pandas as pd
import numpy as np
import os

def parse_date(date_string):
    """Convert date string to timezone-aware datetime"""
    return datetime.strptime(date_string, "%Y-%m-%d %H:%M:%S %z")

def is_in_time_period(date, time_periods):
    """Check if date is within specified time periods"""
    return any(start <= date <= end for start, end in time_periods)

def parse_heart_rate(record):
    """Parse heart rate records"""
    return {
        'type': record.get('type'),
        'value': float(record.get('value')),
        'unit': record.get('unit'),
        'start_date': parse_date(record.get('startDate')),
        'end_date': parse_date(record.get('endDate')),
        'device': record.get('device'),
        'source_name': record.get('sourceName'),
        'source_version': record.get('sourceVersion'),
        'creation_date': parse_date(record.get('creationDate')),
        'motion_context': next((entry.get('value') for entry in record.findall('MetadataEntry') 
                              if entry.get('key') == 'HKMetadataKeyHeartRateMotionContext'), None)
    }

def parse_activity_record(record):
    """Generic parser for activity records (steps, distance, flights)"""
    try:
        return {
            'start_date': parse_date(record.get('startDate')),
            'end_date': parse_date(record.get('endDate')),
            'value': float(record.get('value')),
            'source': record.get('sourceName'),
            'device': record.get('device')
        }
    except (ValueError, TypeError):
        return None

def deduplicate_health_records(records):
    """
    Deduplicate health records prioritizing Apple Watch data.
    When Watch and iPhone data overlap in time, use Watch data only.
    When no overlap, keep records from both devices.
    """
    if not records:
        return []

    def has_time_overlap(rec1, rec2):
        """Check if two records overlap in time"""
        return (rec1['start_date'] <= rec2['end_date'] and 
                rec2['start_date'] <= rec1['end_date'])

    sorted_records = sorted(records, key=lambda x: x['start_date'])
    watch_records = [r for r in sorted_records if "Watch" in r['source']]
    iphone_records = [r for r in sorted_records if "Watch" not in r['source']]
    
    final_records = watch_records.copy()
    for iphone_record in iphone_records:
        has_overlap = any(has_time_overlap(iphone_record, watch_record) 
                         for watch_record in watch_records)
        if not has_overlap:
            final_records.append(iphone_record)
    
    return sorted(final_records, key=lambda x: x['start_date'])

def parse_sleep(record):
    """Parse sleep analysis records"""
    return {
        'type': record.get('type'),
        'value': record.get('value'),
        'start_date': parse_date(record.get('startDate')),
        'end_date': parse_date(record.get('endDate')),
        'source_name': record.get('sourceName'),
        'source_version': record.get('sourceVersion'),
        'creation_date': parse_date(record.get('creationDate'))
    }

def parse_workout(workout):
    """Parse workout records"""
    workout_data = {
        'type': workout.get('workoutActivityType'),
        'start_time': parse_date(workout.get('startDate')),
        'end_time': parse_date(workout.get('endDate')),
        'duration': float(workout.get('duration')),
        'duration_unit': workout.get('durationUnit'),
        'total_distance': None,
        'total_energy_burned': None,
        'avg_heart_rate': None,
        'min_heart_rate': None,
        'max_heart_rate': None,
        'avg_mets': None,
        'temperature': None,
        'humidity': None,
        'elevation_ascended': None,
        'num_segments': 0,
    }

    for entry in workout.findall('MetadataEntry'):
        key, value = entry.get('key'), entry.get('value')
        if key == 'HKWeatherTemperature':
            workout_data['temperature'] = float(value.split()[0])
        elif key == 'HKWeatherHumidity':
            workout_data['humidity'] = float(value.split()[0]) / 100
        elif key == 'HKAverageMETs':
            workout_data['avg_mets'] = float(value.split()[0])
        elif key == 'HKElevationAscended':
            workout_data['elevation_ascended'] = float(value.split()[0])

    workout_data['num_segments'] = len(workout.findall('WorkoutEvent'))

    for stat in workout.findall('WorkoutStatistics'):
        stat_type = stat.get('type')
        if stat_type == 'HKQuantityTypeIdentifierDistanceWalkingRunning':
            workout_data['total_distance'] = float(stat.get('sum'))
        elif stat_type == 'HKQuantityTypeIdentifierActiveEnergyBurned':
            workout_data['total_energy_burned'] = float(stat.get('sum'))
        elif stat_type == 'HKQuantityTypeIdentifierHeartRate':
            workout_data['avg_heart_rate'] = float(stat.get('average'))
            workout_data['min_heart_rate'] = float(stat.get('minimum'))
            workout_data['max_heart_rate'] = float(stat.get('maximum'))

    return workout_data

def process_sleep_data(sleep_data):
    """
    Process sleep records based on creation_date (date only).
    If both iPhone and Watch data exist for the same date, use only Watch data.
    """
    if not sleep_data:
        return pd.DataFrame()
    
    # Convert to DataFrame
    df = pd.DataFrame(sleep_data)
    
    # Add date-only column for creation_date grouping
    df['creation_date_day'] = df['creation_date'].dt.date
    
    def process_sleep_group(group):
        """Process a group of sleep records with same creation date"""
        # Check if this date has any Watch data
        has_watch_data = group['source_name'].str.contains('Watch', na=False).any()
        
        if has_watch_data:
            # Use only Watch sleep states
            watch_sleep_states = group[
                (group['source_name'].str.contains('Watch', na=False)) &
                (group['value'].isin([
                    'HKCategoryValueSleepAnalysisAsleepCore',
                    'HKCategoryValueSleepAnalysisAsleepDeep',
                    'HKCategoryValueSleepAnalysisAsleepREM'
                ]))
            ]
            
            if watch_sleep_states.empty:
                return None
                
            start_date = watch_sleep_states['start_date'].min()
            end_date = watch_sleep_states['end_date'].max()
            
            # Calculate duration for each sleep state
            core_sleep = pd.Timedelta(0)
            deep_sleep = pd.Timedelta(0)
            rem_sleep = pd.Timedelta(0)
            
            for _, row in watch_sleep_states.iterrows():
                duration = row['end_date'] - row['start_date']
                if row['value'] == 'HKCategoryValueSleepAnalysisAsleepCore':
                    core_sleep += duration
                elif row['value'] == 'HKCategoryValueSleepAnalysisAsleepDeep':
                    deep_sleep += duration
                elif row['value'] == 'HKCategoryValueSleepAnalysisAsleepREM':
                    rem_sleep += duration
            
            total_sleep = core_sleep + deep_sleep + rem_sleep
            
        else:
            # Use iPhone InBed data
            iphone_data = group[
                (group['source_name'].str.contains('iPhone', na=False)) &
                (group['value'] == 'HKCategoryValueSleepAnalysisInBed')
            ]
            
            if iphone_data.empty:
                return None
                
            start_date = iphone_data['start_date'].min()
            end_date = iphone_data['end_date'].max()
            
            # For iPhone data, calculate total duration as core sleep
            total_sleep = core_sleep = pd.Timedelta(0)
            for _, row in iphone_data.iterrows():
                duration = row['end_date'] - row['start_date']
                total_sleep += duration
            
            core_sleep = total_sleep
            deep_sleep = pd.Timedelta(0)
            rem_sleep = pd.Timedelta(0)
        
        return pd.Series({
            'start_date': start_date,
            'end_date': end_date,
            'total_sleep_time': total_sleep,
            'core_sleep_time': core_sleep,
            'deep_sleep_time': deep_sleep,
            'rem_sleep_time': rem_sleep
        })
    
    # Process each creation_date_day group
    results = []
    for _, group in df.groupby('creation_date_day'):
        result = process_sleep_group(group)
        if result is not None:
            results.append(result)
    
    if not results:
        return pd.DataFrame()
    
    # Create final DataFrame and sort by start_date
    result_df = pd.DataFrame(results).sort_values('start_date')
    
    # Ensure all timestamps are in KST
    for col in ['start_date', 'end_date']:
        if result_df[col].dt.tz is None:
            result_df[col] = result_df[col].dt.tz_localize('Asia/Seoul')
        else:
            result_df[col] = result_df[col].dt.tz_convert('Asia/Seoul')
    
    return result_df

def aggregate_data(df, interval='10min'):
    """Aggregate data into specified time intervals"""
    if df.empty:
        return pd.DataFrame(columns=['start_time', 'end_time', 'value'])

    distributed_records = []
    for _, row in df.iterrows():
        start = row['start_date']
        end = row['end_date']
        value = row['value']
        
        intervals = pd.date_range(
            start=start.floor(interval),
            end=end.ceil(interval),
            freq=interval,
            tz=start.tzinfo
        )
        
        for interval_start, interval_end in zip(intervals, intervals[1:]):
            overlap_start = max(start, interval_start)
            overlap_end = min(end, interval_end)
            overlap_duration = (overlap_end - overlap_start).total_seconds()
            total_duration = (end - start).total_seconds()
            
            if overlap_duration > 0:
                interval_value = value * (overlap_duration / total_duration)
                distributed_records.append({
                    'start_time': interval_start,
                    'end_time': interval_end,
                    'value': interval_value
                })
    
    result_df = pd.DataFrame(distributed_records)
    if not result_df.empty:
        result_df['value'] = result_df['value'].astype(float)
        aggregated = result_df.groupby(['start_time', 'end_time'])['value'].sum().reset_index()
        return aggregated
    return result_df

def parse_apple_health_data(xml_file, time_periods):
    """Main function to parse Apple Health data"""
    print("Reading XML file...")
    tree = ET.parse(xml_file)
    root = tree.getroot()
    
    heart_rate_data = []
    sleep_data = []
    step_data = []
    distance_data = []
    flights_climbed_data = []
    workout_data = []
    
    print("Processing records...")
    for record in root.findall('.//Record'):
        start_date = parse_date(record.get('startDate'))
        if is_in_time_period(start_date, time_periods):
            record_type = record.get('type')
            
            if record_type == 'HKQuantityTypeIdentifierHeartRate':
                heart_rate_data.append(parse_heart_rate(record))
            elif record_type == 'HKCategoryTypeIdentifierSleepAnalysis':
                sleep_data.append(parse_sleep(record))
            elif record_type == 'HKQuantityTypeIdentifierStepCount':
                parsed_record = parse_activity_record(record)
                if parsed_record:
                    step_data.append(parsed_record)
            elif record_type == 'HKQuantityTypeIdentifierDistanceWalkingRunning':
                parsed_record = parse_activity_record(record)
                if parsed_record:
                    distance_data.append(parsed_record)
            elif record_type == 'HKQuantityTypeIdentifierFlightsClimbed':
                parsed_record = parse_activity_record(record)
                if parsed_record:
                    flights_climbed_data.append(parsed_record)

    print("Processing workout data...")
    for workout in root.findall('.//Workout'):
        start_date = parse_date(workout.get('startDate'))
        if is_in_time_period(start_date, time_periods):
            workout_data.append(parse_workout(workout))

    print("Deduplicating and aggregating activity data...")
    # Deduplicate and aggregate each activity metric
    deduplicated_steps = deduplicate_health_records(step_data)
    deduplicated_distance = deduplicate_health_records(distance_data)
    deduplicated_flights = deduplicate_health_records(flights_climbed_data)

    # Convert to DataFrames
    heart_rate_df = pd.DataFrame(heart_rate_data)
    steps_df = pd.DataFrame(deduplicated_steps)
    distance_df = pd.DataFrame(deduplicated_distance)
    flights_df = pd.DataFrame(deduplicated_flights)
    workout_df = pd.DataFrame(workout_data)

    # Aggregate activity data
    print("Creating final DataFrames...")
    if not steps_df.empty:
        aggregated_steps = aggregate_data(steps_df)
        aggregated_steps['value'] = aggregated_steps['value'].round().astype(int)
        aggregated_steps = aggregated_steps.rename(columns={'value': 'steps'})
    else:
        aggregated_steps = pd.DataFrame(columns=['start_time', 'end_time', 'steps'])

    if not distance_df.empty:
        aggregated_distance = aggregate_data(distance_df)
        aggregated_distance['value'] = aggregated_distance['value'].round(3)
        aggregated_distance = aggregated_distance.rename(columns={'value': 'distance'})
    else:
        aggregated_distance = pd.DataFrame(columns=['start_time', 'end_time', 'distance'])

    if not flights_df.empty:
        aggregated_flights = aggregate_data(flights_df)
        aggregated_flights['value'] = aggregated_flights['value'].round(3)
        aggregated_flights = aggregated_flights.rename(columns={'value': 'flights'})
    else:
        aggregated_flights = pd.DataFrame(columns=['start_time', 'end_time', 'flights'])

    # Process sleep data
    sleep_df = process_sleep_data(sleep_data)

    # Merge all activity data
    print("Merging activity data...")
    aggregated_data = pd.merge(
        aggregated_steps,
        aggregated_distance[['start_time', 'distance']],
        on='start_time',
        how='outer'
    )
    aggregated_data = pd.merge(
        aggregated_data,
        aggregated_flights[['start_time', 'flights']],
        on='start_time',
        how='outer'
    )
    aggregated_data = aggregated_data.fillna(0)

    return heart_rate_df, aggregated_data, sleep_df, workout_df


def save_dataframes_to_csv(heart_rate_df, aggregated_data, sleep_df, workout_df):
    """Save processed data to CSV files"""
    output_dir = os.path.join('data', 'processed')
    print(f"Attempting to save files to: {output_dir}")
    os.makedirs(output_dir, exist_ok=True)
    
    def format_date(dt):
        if pd.isna(dt):
            return dt
        return dt.strftime('%Y-%m-%d %H:%M:%S%z')
    
    for df, filename in [
        (heart_rate_df, 'heart_rate_data.csv'),
        (aggregated_data, 'aggregated_activity_data.csv'),
        (sleep_df, 'sleep_data.csv'),
        (workout_df, 'workout_data.csv')
    ]:
        if not df.empty:
            file_path = os.path.join(output_dir, filename)
            print(f"Saving {filename} to: {file_path}")
            for col in df.select_dtypes(include=['datetime64']).columns:
                df[col] = df[col].apply(format_date)
            df.to_csv(file_path, index=False)
            print(f"Saved {filename}")

def extract_time_periods(glucose_data_file):
    """Extract time periods from glucose data"""
    df = pd.read_csv(glucose_data_file)
    df['DateTime'] = pd.to_datetime(df['DateTime'])
    
    # Define KST timezone
    kst = timezone(timedelta(hours=9))
    
    # Check if datetime is timezone-naive
    if df['DateTime'].dt.tz is None:
        df['DateTime'] = df['DateTime'].dt.tz_localize(kst)
    else:
        # If already tz-aware, convert to KST
        df['DateTime'] = df['DateTime'].dt.tz_convert(kst)
    
    time_periods = []
    for measurement_number, group in df.groupby('MeasurementNumber'):
        start_time = group['DateTime'].min()
        end_time = group['DateTime'].max()
        time_periods.append((start_time, end_time))
    
    return time_periods
```

